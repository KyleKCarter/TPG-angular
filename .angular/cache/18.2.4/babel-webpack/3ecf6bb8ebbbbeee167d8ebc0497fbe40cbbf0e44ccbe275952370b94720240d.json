{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Component, ChangeDetectionStrategy, ViewEncapsulation, Input, InjectionToken, numberAttribute, inject, CSP_NONCE, ChangeDetectorRef, PLATFORM_ID, booleanAttribute, Inject, Output, ViewChild, NgModule } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, BehaviorSubject, fromEventPattern, of, Observable } from 'rxjs';\nimport { switchMap, takeUntil } from 'rxjs/operators';\nconst _c0 = [\"youtubeContainer\"];\nfunction YouTubePlayer_Conditional_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"youtube-player-placeholder\", 2);\n    i0.ɵɵlistener(\"click\", function YouTubePlayer_Conditional_0_Template_youtube_player_placeholder_click_0_listener() {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1._load(true));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"videoId\", ctx_r1.videoId)(\"width\", ctx_r1.width)(\"height\", ctx_r1.height)(\"isLoading\", ctx_r1._isLoading)(\"buttonLabel\", ctx_r1.placeholderButtonLabel)(\"quality\", ctx_r1.placeholderImageQuality);\n  }\n}\nlet YouTubePlayerPlaceholder = /*#__PURE__*/(() => {\n  class YouTubePlayerPlaceholder {\n    /** Gets the background image showing the placeholder. */\n    _getBackgroundImage() {\n      let url;\n      if (this.quality === 'low') {\n        url = `https://i.ytimg.com/vi/${this.videoId}/hqdefault.jpg`;\n      } else if (this.quality === 'high') {\n        url = `https://i.ytimg.com/vi/${this.videoId}/maxresdefault.jpg`;\n      } else {\n        url = `https://i.ytimg.com/vi_webp/${this.videoId}/sddefault.webp`;\n      }\n      return `url(${url})`;\n    }\n    static #_ = (() => this.ɵfac = function YouTubePlayerPlaceholder_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || YouTubePlayerPlaceholder)();\n    })();\n    static #_2 = (() => this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: YouTubePlayerPlaceholder,\n      selectors: [[\"youtube-player-placeholder\"]],\n      hostAttrs: [1, \"youtube-player-placeholder\"],\n      hostVars: 8,\n      hostBindings: function YouTubePlayerPlaceholder_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵstyleProp(\"background-image\", ctx._getBackgroundImage())(\"width\", ctx.width, \"px\")(\"height\", ctx.height, \"px\");\n          i0.ɵɵclassProp(\"youtube-player-placeholder-loading\", ctx.isLoading);\n        }\n      },\n      inputs: {\n        videoId: \"videoId\",\n        width: \"width\",\n        height: \"height\",\n        isLoading: \"isLoading\",\n        buttonLabel: \"buttonLabel\",\n        quality: \"quality\"\n      },\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      decls: 4,\n      vars: 1,\n      consts: [[\"type\", \"button\", 1, \"youtube-player-placeholder-button\"], [\"height\", \"100%\", \"version\", \"1.1\", \"viewBox\", \"0 0 68 48\", \"focusable\", \"false\", \"aria-hidden\", \"true\"], [\"d\", \"M66.52,7.74c-0.78-2.93-2.49-5.41-5.42-6.19C55.79,.13,34,0,34,0S12.21,.13,6.9,1.55 C3.97,2.33,2.27,4.81,1.48,7.74C0.06,13.05,0,24,0,24s0.06,10.95,1.48,16.26c0.78,2.93,2.49,5.41,5.42,6.19 C12.21,47.87,34,48,34,48s21.79-0.13,27.1-1.55c2.93-0.78,4.64-3.26,5.42-6.19C67.94,34.95,68,24,68,24S67.94,13.05,66.52,7.74z\", \"fill\", \"#f00\"], [\"d\", \"M 45,24 27,14 27,34\", \"fill\", \"#fff\"]],\n      template: function YouTubePlayerPlaceholder_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"button\", 0);\n          i0.ɵɵnamespaceSVG();\n          i0.ɵɵelementStart(1, \"svg\", 1);\n          i0.ɵɵelement(2, \"path\", 2)(3, \"path\", 3);\n          i0.ɵɵelementEnd()();\n        }\n        if (rf & 2) {\n          i0.ɵɵattribute(\"aria-label\", ctx.buttonLabel);\n        }\n      },\n      styles: [\".youtube-player-placeholder{display:flex;align-items:center;justify-content:center;width:100%;overflow:hidden;cursor:pointer;background-color:#000;background-position:center center;background-size:cover;transition:box-shadow 300ms ease;box-shadow:inset 0 120px 90px -90px rgba(0,0,0,.8)}.youtube-player-placeholder-button{transition:opacity 300ms ease;-moz-appearance:none;-webkit-appearance:none;background:none;border:none;padding:0;display:flex}.youtube-player-placeholder-button svg{width:68px;height:48px}.youtube-player-placeholder-loading{box-shadow:none}.youtube-player-placeholder-loading .youtube-player-placeholder-button{opacity:0}\"],\n      encapsulation: 2,\n      changeDetection: 0\n    }))();\n  }\n  return YouTubePlayerPlaceholder;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// Workaround for: https://github.com/bazelbuild/rules_nodejs/issues/1265\n/** Injection token used to configure the `YouTubePlayer`. */\nconst YOUTUBE_PLAYER_CONFIG = /*#__PURE__*/new InjectionToken('YOUTUBE_PLAYER_CONFIG');\nconst DEFAULT_PLAYER_WIDTH = 640;\nconst DEFAULT_PLAYER_HEIGHT = 390;\n/** Coercion function for time values. */\nfunction coerceTime(value) {\n  return value == null ? value : numberAttribute(value, 0);\n}\n/**\n * Equivalent of `YT.PlayerState` which we can't use, because it's meant to\n * be read off the `window` which we can't do before the API has been loaded.\n */\nvar PlayerState = /*#__PURE__*/function (PlayerState) {\n  PlayerState[PlayerState[\"UNSTARTED\"] = -1] = \"UNSTARTED\";\n  PlayerState[PlayerState[\"ENDED\"] = 0] = \"ENDED\";\n  PlayerState[PlayerState[\"PLAYING\"] = 1] = \"PLAYING\";\n  PlayerState[PlayerState[\"PAUSED\"] = 2] = \"PAUSED\";\n  PlayerState[PlayerState[\"BUFFERING\"] = 3] = \"BUFFERING\";\n  PlayerState[PlayerState[\"CUED\"] = 5] = \"CUED\";\n  return PlayerState;\n}(PlayerState || {});\n/**\n * Angular component that renders a YouTube player via the YouTube player\n * iframe API.\n * @see https://developers.google.com/youtube/iframe_api_reference\n */\nlet YouTubePlayer = /*#__PURE__*/(() => {\n  class YouTubePlayer {\n    /** Height of video player */\n    get height() {\n      return this._height;\n    }\n    set height(height) {\n      this._height = height == null || isNaN(height) ? DEFAULT_PLAYER_HEIGHT : height;\n    }\n    /** Width of video player */\n    get width() {\n      return this._width;\n    }\n    set width(width) {\n      this._width = width == null || isNaN(width) ? DEFAULT_PLAYER_WIDTH : width;\n    }\n    constructor(_ngZone, platformId) {\n      this._ngZone = _ngZone;\n      this._destroyed = new Subject();\n      this._playerChanges = new BehaviorSubject(undefined);\n      this._nonce = inject(CSP_NONCE, {\n        optional: true\n      });\n      this._changeDetectorRef = inject(ChangeDetectorRef);\n      this._isLoading = false;\n      this._hasPlaceholder = true;\n      this._height = DEFAULT_PLAYER_HEIGHT;\n      this._width = DEFAULT_PLAYER_WIDTH;\n      /** Whether cookies inside the player have been disabled. */\n      this.disableCookies = false;\n      /**\n       * By default the player shows a placeholder image instead of loading the YouTube API which\n       * improves the initial page load performance. This input allows for the behavior to be disabled.\n       */\n      this.disablePlaceholder = false;\n      /**\n       * Whether the iframe will attempt to load regardless of the status of the api on the\n       * page. Set this to true if you don't want the `onYouTubeIframeAPIReady` field to be\n       * set on the global window.\n       */\n      this.showBeforeIframeApiLoads = false;\n      /** Outputs are direct proxies from the player itself. */\n      this.ready = this._getLazyEmitter('onReady');\n      this.stateChange = this._getLazyEmitter('onStateChange');\n      this.error = this._getLazyEmitter('onError');\n      this.apiChange = this._getLazyEmitter('onApiChange');\n      this.playbackQualityChange = this._getLazyEmitter('onPlaybackQualityChange');\n      this.playbackRateChange = this._getLazyEmitter('onPlaybackRateChange');\n      const config = inject(YOUTUBE_PLAYER_CONFIG, {\n        optional: true\n      });\n      this.loadApi = config?.loadApi ?? true;\n      this.disablePlaceholder = !!config?.disablePlaceholder;\n      this.placeholderButtonLabel = config?.placeholderButtonLabel || 'Play video';\n      this.placeholderImageQuality = config?.placeholderImageQuality || 'standard';\n      this._isBrowser = isPlatformBrowser(platformId);\n    }\n    ngAfterViewInit() {\n      this._conditionallyLoad();\n    }\n    ngOnChanges(changes) {\n      if (this._shouldRecreatePlayer(changes)) {\n        this._conditionallyLoad();\n      } else if (this._player) {\n        if (changes['width'] || changes['height']) {\n          this._setSize();\n        }\n        if (changes['suggestedQuality']) {\n          this._setQuality();\n        }\n        if (changes['startSeconds'] || changes['endSeconds'] || changes['suggestedQuality']) {\n          this._cuePlayer();\n        }\n      }\n    }\n    ngOnDestroy() {\n      this._pendingPlayer?.destroy();\n      if (this._player) {\n        this._player.destroy();\n        window.onYouTubeIframeAPIReady = this._existingApiReadyCallback;\n      }\n      this._playerChanges.complete();\n      this._destroyed.next();\n      this._destroyed.complete();\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#playVideo */\n    playVideo() {\n      if (this._player) {\n        this._player.playVideo();\n      } else {\n        this._getPendingState().playbackState = PlayerState.PLAYING;\n        this._load(true);\n      }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#pauseVideo */\n    pauseVideo() {\n      if (this._player) {\n        this._player.pauseVideo();\n      } else {\n        this._getPendingState().playbackState = PlayerState.PAUSED;\n      }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#stopVideo */\n    stopVideo() {\n      if (this._player) {\n        this._player.stopVideo();\n      } else {\n        // It seems like YouTube sets the player to CUED when it's stopped.\n        this._getPendingState().playbackState = PlayerState.CUED;\n      }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#seekTo */\n    seekTo(seconds, allowSeekAhead) {\n      if (this._player) {\n        this._player.seekTo(seconds, allowSeekAhead);\n      } else {\n        this._getPendingState().seek = {\n          seconds,\n          allowSeekAhead\n        };\n      }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#mute */\n    mute() {\n      if (this._player) {\n        this._player.mute();\n      } else {\n        this._getPendingState().muted = true;\n      }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#unMute */\n    unMute() {\n      if (this._player) {\n        this._player.unMute();\n      } else {\n        this._getPendingState().muted = false;\n      }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#isMuted */\n    isMuted() {\n      if (this._player) {\n        return this._player.isMuted();\n      }\n      if (this._pendingPlayerState) {\n        return !!this._pendingPlayerState.muted;\n      }\n      return false;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#setVolume */\n    setVolume(volume) {\n      if (this._player) {\n        this._player.setVolume(volume);\n      } else {\n        this._getPendingState().volume = volume;\n      }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getVolume */\n    getVolume() {\n      if (this._player) {\n        return this._player.getVolume();\n      }\n      if (this._pendingPlayerState && this._pendingPlayerState.volume != null) {\n        return this._pendingPlayerState.volume;\n      }\n      return 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#setPlaybackRate */\n    setPlaybackRate(playbackRate) {\n      if (this._player) {\n        return this._player.setPlaybackRate(playbackRate);\n      } else {\n        this._getPendingState().playbackRate = playbackRate;\n      }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getPlaybackRate */\n    getPlaybackRate() {\n      if (this._player) {\n        return this._player.getPlaybackRate();\n      }\n      if (this._pendingPlayerState && this._pendingPlayerState.playbackRate != null) {\n        return this._pendingPlayerState.playbackRate;\n      }\n      return 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getAvailablePlaybackRates */\n    getAvailablePlaybackRates() {\n      return this._player ? this._player.getAvailablePlaybackRates() : [];\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getVideoLoadedFraction */\n    getVideoLoadedFraction() {\n      return this._player ? this._player.getVideoLoadedFraction() : 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getPlayerState */\n    getPlayerState() {\n      if (!this._isBrowser || !window.YT) {\n        return undefined;\n      }\n      if (this._player) {\n        return this._player.getPlayerState();\n      }\n      if (this._pendingPlayerState && this._pendingPlayerState.playbackState != null) {\n        return this._pendingPlayerState.playbackState;\n      }\n      return PlayerState.UNSTARTED;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getCurrentTime */\n    getCurrentTime() {\n      if (this._player) {\n        return this._player.getCurrentTime();\n      }\n      if (this._pendingPlayerState && this._pendingPlayerState.seek) {\n        return this._pendingPlayerState.seek.seconds;\n      }\n      return 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getPlaybackQuality */\n    getPlaybackQuality() {\n      return this._player ? this._player.getPlaybackQuality() : 'default';\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getAvailableQualityLevels */\n    getAvailableQualityLevels() {\n      return this._player ? this._player.getAvailableQualityLevels() : [];\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getDuration */\n    getDuration() {\n      return this._player ? this._player.getDuration() : 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getVideoUrl */\n    getVideoUrl() {\n      return this._player ? this._player.getVideoUrl() : '';\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getVideoEmbedCode */\n    getVideoEmbedCode() {\n      return this._player ? this._player.getVideoEmbedCode() : '';\n    }\n    /**\n     * Loads the YouTube API and sets up the player.\n     * @param playVideo Whether to automatically play the video once the player is loaded.\n     */\n    _load(playVideo) {\n      // Don't do anything if we're not in a browser environment.\n      if (!this._isBrowser) {\n        return;\n      }\n      if (!window.YT || !window.YT.Player) {\n        if (this.loadApi) {\n          this._isLoading = true;\n          loadApi(this._nonce);\n        } else if (this.showBeforeIframeApiLoads && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n          throw new Error('Namespace YT not found, cannot construct embedded youtube player. ' + 'Please install the YouTube Player API Reference for iframe Embeds: ' + 'https://developers.google.com/youtube/iframe_api_reference');\n        }\n        this._existingApiReadyCallback = window.onYouTubeIframeAPIReady;\n        window.onYouTubeIframeAPIReady = () => {\n          this._existingApiReadyCallback?.();\n          this._ngZone.run(() => this._createPlayer(playVideo));\n        };\n      } else {\n        this._createPlayer(playVideo);\n      }\n    }\n    /** Loads the player depending on the internal state of the component. */\n    _conditionallyLoad() {\n      // If the placeholder isn't shown anymore, we have to trigger a load.\n      if (!this._shouldShowPlaceholder()) {\n        this._load(false);\n      } else if (this.playerVars?.autoplay === 1) {\n        // If it's an autoplaying video, we have to hide the placeholder and start playing.\n        this._load(true);\n      }\n    }\n    /** Whether to show the placeholder element. */\n    _shouldShowPlaceholder() {\n      if (this.disablePlaceholder) {\n        return false;\n      }\n      // Since we don't load the API on the server, we show the placeholder permanently.\n      if (!this._isBrowser) {\n        return true;\n      }\n      return this._hasPlaceholder && !!this.videoId && !this._player;\n    }\n    /** Gets an object that should be used to store the temporary API state. */\n    _getPendingState() {\n      if (!this._pendingPlayerState) {\n        this._pendingPlayerState = {};\n      }\n      return this._pendingPlayerState;\n    }\n    /**\n     * Determines whether a change in the component state\n     * requires the YouTube player to be recreated.\n     */\n    _shouldRecreatePlayer(changes) {\n      const change = changes['videoId'] || changes['playerVars'] || changes['disableCookies'] || changes['disablePlaceholder'];\n      return !!change && !change.isFirstChange();\n    }\n    /**\n     * Creates a new YouTube player and destroys the existing one.\n     * @param playVideo Whether to play the video once it loads.\n     */\n    _createPlayer(playVideo) {\n      this._player?.destroy();\n      this._pendingPlayer?.destroy();\n      // A player can't be created if the API isn't loaded,\n      // or there isn't a video or playlist to be played.\n      if (typeof YT === 'undefined' || !this.videoId && !this.playerVars?.list) {\n        return;\n      }\n      // Important! We need to create the Player object outside of the `NgZone`, because it kicks\n      // off a 250ms setInterval which will continually trigger change detection if we don't.\n      const player = this._ngZone.runOutsideAngular(() => new YT.Player(this.youtubeContainer.nativeElement, {\n        videoId: this.videoId,\n        host: this.disableCookies ? 'https://www.youtube-nocookie.com' : undefined,\n        width: this.width,\n        height: this.height,\n        // Calling `playVideo` on load doesn't appear to actually play\n        // the video so we need to trigger it through `playerVars` instead.\n        playerVars: playVideo ? {\n          ...(this.playerVars || {}),\n          autoplay: 1\n        } : this.playerVars\n      }));\n      const whenReady = () => {\n        // Only assign the player once it's ready, otherwise YouTube doesn't expose some APIs.\n        this._ngZone.run(() => {\n          this._isLoading = false;\n          this._hasPlaceholder = false;\n          this._player = player;\n          this._pendingPlayer = undefined;\n          player.removeEventListener('onReady', whenReady);\n          this._playerChanges.next(player);\n          this._setSize();\n          this._setQuality();\n          if (this._pendingPlayerState) {\n            this._applyPendingPlayerState(player, this._pendingPlayerState);\n            this._pendingPlayerState = undefined;\n          }\n          // Only cue the player when it either hasn't started yet or it's cued,\n          // otherwise cuing it can interrupt a player with autoplay enabled.\n          const state = player.getPlayerState();\n          if (state === PlayerState.UNSTARTED || state === PlayerState.CUED || state == null) {\n            this._cuePlayer();\n          }\n          this._changeDetectorRef.markForCheck();\n        });\n      };\n      this._pendingPlayer = player;\n      player.addEventListener('onReady', whenReady);\n    }\n    /** Applies any state that changed before the player was initialized. */\n    _applyPendingPlayerState(player, pendingState) {\n      const {\n        playbackState,\n        playbackRate,\n        volume,\n        muted,\n        seek\n      } = pendingState;\n      switch (playbackState) {\n        case PlayerState.PLAYING:\n          player.playVideo();\n          break;\n        case PlayerState.PAUSED:\n          player.pauseVideo();\n          break;\n        case PlayerState.CUED:\n          player.stopVideo();\n          break;\n      }\n      if (playbackRate != null) {\n        player.setPlaybackRate(playbackRate);\n      }\n      if (volume != null) {\n        player.setVolume(volume);\n      }\n      if (muted != null) {\n        muted ? player.mute() : player.unMute();\n      }\n      if (seek != null) {\n        player.seekTo(seek.seconds, seek.allowSeekAhead);\n      }\n    }\n    /** Cues the player based on the current component state. */\n    _cuePlayer() {\n      if (this._player && this.videoId) {\n        this._player.cueVideoById({\n          videoId: this.videoId,\n          startSeconds: this.startSeconds,\n          endSeconds: this.endSeconds,\n          suggestedQuality: this.suggestedQuality\n        });\n      }\n    }\n    /** Sets the player's size based on the current input values. */\n    _setSize() {\n      this._player?.setSize(this.width, this.height);\n    }\n    /** Sets the player's quality based on the current input values. */\n    _setQuality() {\n      if (this._player && this.suggestedQuality) {\n        this._player.setPlaybackQuality(this.suggestedQuality);\n      }\n    }\n    /** Gets an observable that adds an event listener to the player when a user subscribes to it. */\n    _getLazyEmitter(name) {\n      // Start with the stream of players. This way the events will be transferred\n      // over to the new player if it gets swapped out under-the-hood.\n      return this._playerChanges.pipe(\n      // Switch to the bound event. `switchMap` ensures that the old event is removed when the\n      // player is changed. If there's no player, return an observable that never emits.\n      switchMap(player => {\n        return player ? fromEventPattern(listener => {\n          player.addEventListener(name, listener);\n        }, listener => {\n          // The API seems to throw when we try to unbind from a destroyed player and it doesn't\n          // expose whether the player has been destroyed so we have to wrap it in a try/catch to\n          // prevent the entire stream from erroring out.\n          try {\n            player?.removeEventListener?.(name, listener);\n          } catch {}\n        }) : of();\n      }),\n      // By default we run all the API interactions outside the zone\n      // so we have to bring the events back in manually when they emit.\n      source => new Observable(observer => source.subscribe({\n        next: value => this._ngZone.run(() => observer.next(value)),\n        error: error => observer.error(error),\n        complete: () => observer.complete()\n      })),\n      // Ensures that everything is cleared out on destroy.\n      takeUntil(this._destroyed));\n    }\n    static #_ = (() => this.ɵfac = function YouTubePlayer_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || YouTubePlayer)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(PLATFORM_ID));\n    })();\n    static #_2 = (() => this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: YouTubePlayer,\n      selectors: [[\"youtube-player\"]],\n      viewQuery: function YouTubePlayer_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(_c0, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.youtubeContainer = _t.first);\n        }\n      },\n      inputs: {\n        videoId: \"videoId\",\n        height: [2, \"height\", \"height\", numberAttribute],\n        width: [2, \"width\", \"width\", numberAttribute],\n        startSeconds: [2, \"startSeconds\", \"startSeconds\", coerceTime],\n        endSeconds: [2, \"endSeconds\", \"endSeconds\", coerceTime],\n        suggestedQuality: \"suggestedQuality\",\n        playerVars: \"playerVars\",\n        disableCookies: [2, \"disableCookies\", \"disableCookies\", booleanAttribute],\n        loadApi: [2, \"loadApi\", \"loadApi\", booleanAttribute],\n        disablePlaceholder: [2, \"disablePlaceholder\", \"disablePlaceholder\", booleanAttribute],\n        showBeforeIframeApiLoads: [2, \"showBeforeIframeApiLoads\", \"showBeforeIframeApiLoads\", booleanAttribute],\n        placeholderButtonLabel: \"placeholderButtonLabel\",\n        placeholderImageQuality: \"placeholderImageQuality\"\n      },\n      outputs: {\n        ready: \"ready\",\n        stateChange: \"stateChange\",\n        error: \"error\",\n        apiChange: \"apiChange\",\n        playbackQualityChange: \"playbackQualityChange\",\n        playbackRateChange: \"playbackRateChange\"\n      },\n      standalone: true,\n      features: [i0.ɵɵInputTransformsFeature, i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n      decls: 4,\n      vars: 3,\n      consts: [[\"youtubeContainer\", \"\"], [3, \"videoId\", \"width\", \"height\", \"isLoading\", \"buttonLabel\", \"quality\"], [3, \"click\", \"videoId\", \"width\", \"height\", \"isLoading\", \"buttonLabel\", \"quality\"]],\n      template: function YouTubePlayer_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵtemplate(0, YouTubePlayer_Conditional_0_Template, 1, 6, \"youtube-player-placeholder\", 1);\n          i0.ɵɵelementStart(1, \"div\");\n          i0.ɵɵelement(2, \"div\", null, 0);\n          i0.ɵɵelementEnd();\n        }\n        if (rf & 2) {\n          i0.ɵɵconditional(ctx._shouldShowPlaceholder() ? 0 : -1);\n          i0.ɵɵadvance();\n          i0.ɵɵstyleProp(\"display\", ctx._shouldShowPlaceholder() ? \"none\" : \"\");\n        }\n      },\n      dependencies: [YouTubePlayerPlaceholder],\n      encapsulation: 2,\n      changeDetection: 0\n    }))();\n  }\n  return YouTubePlayer;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet apiLoaded = false;\n/** Loads the YouTube API from a specified URL only once. */\nfunction loadApi(nonce) {\n  if (apiLoaded) {\n    return;\n  }\n  // We can use `document` directly here, because this logic doesn't run outside the browser.\n  const url = 'https://www.youtube.com/iframe_api';\n  const script = document.createElement('script');\n  const callback = event => {\n    script.removeEventListener('load', callback);\n    script.removeEventListener('error', callback);\n    if (event.type === 'error') {\n      apiLoaded = false;\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        console.error(`Failed to load YouTube API from ${url}`);\n      }\n    }\n  };\n  script.addEventListener('load', callback);\n  script.addEventListener('error', callback);\n  script.src = url;\n  script.async = true;\n  if (nonce) {\n    script.setAttribute('nonce', nonce);\n  }\n  // Set this immediately to true so we don't start loading another script\n  // while this one is pending. If loading fails, we'll flip it back to false.\n  apiLoaded = true;\n  document.body.appendChild(script);\n}\nlet YouTubePlayerModule = /*#__PURE__*/(() => {\n  class YouTubePlayerModule {\n    static #_ = (() => this.ɵfac = function YouTubePlayerModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || YouTubePlayerModule)();\n    })();\n    static #_2 = (() => this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: YouTubePlayerModule\n    }))();\n    static #_3 = (() => this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({}))();\n  }\n  return YouTubePlayerModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { YOUTUBE_PLAYER_CONFIG, YouTubePlayer, YouTubePlayerModule };\n//# sourceMappingURL=youtube-player.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}